/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-pHash.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : pHash
 #	author : miyako
 #	2019/09/09
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-pHash.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- pHash
            
			case 1 :
				PH_Compute_DCT(params);
				break;
			case 2 :
				PH_Compare_MH(params);
				break;
			case 3 :
				PH_Compare_RADISH(params);
				break;
			case 4 :
				PH_Compare_DCT(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void PH_Compute_DCT(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    ulong64 hash;
    
    std::string _Param1;
    paramToPathStr(Param1, _Param1);
    
    int status = ph_dct_imagehash(_Param1.c_str(), hash);
    int64ToParam(hash, Param2);
    Param2.toParamAtIndex(pParams, 2);
    
    returnValue.setIntValue(status);
    returnValue.setReturn(pResult);
}

void PH_Compare_MH(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_REAL Param3;
    C_REAL Param4;
    C_REAL returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    float alpha = Param3.getDoubleValue();
    float lvl = Param4.getDoubleValue();
    int hashalen = 0, hashblen = 0;
    
    std::string _Param1, _Param2;
    paramToPathStr(Param1, _Param1);
    paramToPathStr(Param2, _Param2);
    
    uint8_t* hasha = ph_mh_imagehash(_Param1.c_str(), hashalen, alpha, lvl);
    uint8_t* hashb = ph_mh_imagehash(_Param2.c_str(), hashblen, alpha, lvl);
    
    double hamming_distance = ph_hammingdistance2(hasha, hashalen, hashb, hashblen);
    returnValue.setDoubleValue(hamming_distance);
    returnValue.setReturn(pResult);
}

void PH_Compare_RADISH(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_REAL Param3;
    C_REAL Param4;
    C_LONGINT Param5;
    C_REAL returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    
    double sigma = Param3.getDoubleValue();
    double gamma = Param4.getDoubleValue();
    int N = Param5.getIntValue();
    double threshold = 0.9;
    
    Digest x, y;
    double pcc = 0;
    
    std::string _Param1, _Param2;
    paramToPathStr(Param1, _Param1);
    paramToPathStr(Param2, _Param2);
    
    int status = ph_image_digest(_Param1.c_str(), sigma, gamma, x, N);
    if(status == 0){
        status = ph_image_digest(_Param2.c_str(), sigma, gamma, y, N);
        if(status == 0){
            ph_crosscorr(x, y, pcc, threshold);
        }
    }
    
    returnValue.setDoubleValue(pcc);
    returnValue.setReturn(pResult);
}

void PH_Compare_DCT(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    CUTF8String _hasha, _hashb;
    
    Param1.copyUTF8String(&_hasha);
    Param2.copyUTF8String(&_hashb);
    
    std::stringstream _Param1((const char *)_hasha.c_str());
    std::stringstream _Param2((const char *)_hashb.c_str());
    
    ulong64 hasha;
    ulong64 hashb;
    
    _Param1 >> hasha;
    _Param2 >> hashb;
    
    int hamming_distance = ph_hamming_distance(hasha, hashb);
    
    returnValue.setIntValue(hamming_distance);
    returnValue.setReturn(pResult);
}

#pragma mark -

void int64ToParam(ulong64 value, C_TEXT &param)
{
#ifndef __APPLE__
    char buffer[65];
    memset(buffer, 0, 65);
    _ui64toa(value, buffer, 10);
    CUTF8String _value((const uint8_t *)buffer);
    param.setUTF8String(&_value);
#else
    std::stringstream stream;
    stream << value;
    CUTF8String _value((const uint8_t *)stream.str().c_str());
    param.setUTF8String(&_value);
#endif
}

void paramToPathStr(C_TEXT &param, std::string &path){
#if defined(_MSC_VER)
    char str[1024];
    setlocale( LC_ALL, "" );
    wcstombs(str, (wchar_t*)param.getUTF16StringPtr(), 1024);
    path = str;
#else
    CUTF8String _path;
    param.convertPath();
    param.copyUTF8String(&_path);
    path = (const char *)_path.c_str();
#endif
}
